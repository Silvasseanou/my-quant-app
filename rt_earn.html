import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import akshare as ak
from scipy.signal import argrelextrema
import datetime
import time
import concurrent.futures
import json
import os
import re
import requests # æ–°å¢ï¼šç”¨äºç›´è¿ä¸œæ–¹è´¢å¯Œæ¥å£

# === é…ç½®é¡µé¢ ===
st.set_page_config(layout="wide", page_title="æ³¢æµªç†è®ºå®æˆ˜æŒ‡æŒ¥å®˜ (v9.6 æé€Ÿç›´è¿ç‰ˆ)")

# === æ¨¡æ‹Ÿç›˜æ•°æ®æ–‡ä»¶è·¯å¾„ ===
PAPER_TRADING_FILE = "paper_trading_data.json"

# === ç”¨æˆ·æŒä»“æ•°æ® ===
MY_PORTFOLIO = [
    {"code":"025942","name":"å¹¿å‘æ–°åŠ¨åŠ›æ··åˆC","tags":["è‡ªé€‰"],"cost":2.2752,"hold":829.58, "hold_7d": 0},
    {"code":"004260","name":"å¾·é‚¦ç¨³ç›ˆå¢é•¿çµæ´»é…ç½®æ··åˆA","tags":["è‡ªé€‰"],"cost":1.2839,"hold":3884.19, "hold_7d": 3841.4},
    {"code":"011630","name":"ä¸œè´¢æœ‰è‰²å¢å¼ºA","tags":["è‡ªé€‰"],"cost":2.4796,"hold":2772.07, "hold_7d": 2405.4},
    {"code":"002207","name":"å‰æµ·å¼€æºé‡‘é“¶ç å®æ··åˆC","tags":["è‡ªé€‰"],"cost":2.8347,"hold":1648.5, "hold_7d": 525.39},
    {"code":"019924","name":"åæ³°æŸç‘ä¸­è¯2000æŒ‡æ•°å¢å¼ºC","tags":["è‡ªé€‰"],"cost":1.8628,"hold":209.22, "hold_7d": 0},
    {"code":"014855","name":"å˜‰å®ä¸­è¯åŠå¯¼ä½“æŒ‡æ•°å¢å¼ºå‘èµ·å¼C","tags":["è‡ªé€‰"],"cost":2.2366,"hold":917.59, "hold_7d": 0},
    {"code":"012620","name":"å˜‰å®ä¸­è¯è½¯ä»¶æœåŠ¡ETFè”æ¥C","tags":["è‡ªé€‰"],"cost":0.9037,"hold":4454.87, "hold_7d": 2745.44},
    {"code":"019917","name":"å¯Œå›½åŒ»è¯åˆ›æ–°è‚¡ç¥¨C","tags":["è‡ªé€‰"],"cost":1.8284,"hold":558.54, "hold_7d": 0},
    {"code":"018301","name":"åå¤æ¶ˆè´¹ç”µå­ETFè”æ¥C","tags":["è‡ªé€‰"],"cost":1.7396,"hold":1000,"hold_7d": 1000},
    {"code":"025857","name":"åå¤ä¸­è¯ç”µç½‘è®¾å¤‡ä¸»é¢˜ETFå‘èµ·å¼è”æ¥C","tags":["è‡ªé€‰"],"cost":1.2605,"hold":3000,"hold_7d": 3000},
    {"code":"010956","name":"å¤©å¼˜ä¸­è¯æ™ºèƒ½æ±½è½¦æŒ‡æ•°å‘èµ·å¼C","tags":["è‡ªé€‰"],"cost":1.1928,"hold":2000,"hold_7d": 2000}
]

# === é™æ€ç²¾é€‰æ±  ===
STATIC_POOL = [
    {"code": "000300", "name": "åå¤æ²ªæ·±300ETFè”æ¥A", "type": "å®½åŸº-å¤§ç›˜"},
    {"code": "000688", "name": "æ˜“æ–¹è¾¾ç§‘åˆ›50ETFè”æ¥A", "type": "å®½åŸº-ç§‘åˆ›"},
    {"code": "012414", "name": "æ‹›å•†ä¸­è¯ç™½é…’æŒ‡æ•°C", "type": "æ¶ˆè´¹-ç™½é…’"},
    {"code": "001618", "name": "å¤©å¼˜ä¸­è¯ç”µå­ETFè”æ¥C", "type": "ç§‘æŠ€-ç”µå­"},
    {"code": "010358", "name": "æ˜“æ–¹è¾¾ä¸­è¯äººå·¥æ™ºèƒ½ETFè”æ¥C", "type": "ç§‘æŠ€-AI"},
    {"code": "006479", "name": "å¹¿å‘çº³æ–¯è¾¾å…‹100ETFè”æ¥A", "type": "ç¾è‚¡-ç§‘æŠ€"},
]

# === æ ¸å¿ƒåˆ†æç±» (V9.6 å¢å¼ºç‰ˆ) ===
class ElliottWaveAnalyzer:
    def __init__(self):
        pass

    @st.cache_data(ttl=3600)
    def get_hot_funds(_self):
        """çˆ¬å–å…¨å¸‚åœºçƒ­é—¨åŸºé‡‘"""
        try:
            df = ak.fund_open_fund_rank_em(symbol="è‚¡ç¥¨å‹")
            df = df.head(150)
            hot_list = []
            seen_names = set()
            for _, row in df.iterrows():
                name = row['åŸºé‡‘ç®€ç§°']
                if any(x in name for x in ["å®šå¼€", "æŒæœ‰", "å°é—­", "å…»è€", "FOF", "å®šæœŸ", "åç«¯"]): continue
                base_name = re.sub(r'[A-C]$', '', name)
                if base_name in seen_names: continue
                seen_names.add(base_name)
                
                hot_list.append({
                    "code": str(row['åŸºé‡‘ä»£ç ']),
                    "name": name,
                    "type": "Topçƒ­æ¦œ"
                })
                if len(hot_list) >= 80: break 
            return hot_list
        except: return STATIC_POOL

    def fetch_single_estimation(self, code):
        """
        [V9.6 æ–°å¢] ç›´è¿ä¸œæ–¹è´¢å¯Œæ ¸å¿ƒä¼°å€¼æ¥å£
        URL: https://fundgz.1234567.com.cn/js/{code}.js?rt={ts}
        """
        try:
            ts = int(time.time() * 1000)
            url = f"http://fundgz.1234567.com.cn/js/{code}.js"
            params = {"rt": ts}
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Referer": "http://fund.eastmoney.com/"
            }
            # 1.5ç§’è¶…æ—¶ä¿æŠ¤
            resp = requests.get(url, params=params, headers=headers, timeout=1.5)
            
            if resp.status_code == 200 and resp.text.startswith("jsonpgz("):
                # è§£æ JSONP: jsonpgz({...});
                content = resp.text[8:-2] 
                data = json.loads(content)
                # å­—æ®µ: fundcode, name, jzrq(å‡€å€¼æ—¥æœŸ), dwjz(å•ä½å‡€å€¼), gsz(ä¼°ç®—å€¼), gszzl(ä¼°ç®—æ¶¨å¹…), gztime(ä¼°å€¼æ—¶é—´)
                return {
                    'code': data['fundcode'],
                    'est_nav': float(data['gsz']),
                    'est_pct': float(data['gszzl']),
                    'time': data['gztime']
                }
        except Exception:
            pass
        return None

    @st.cache_data(ttl=30) # 30ç§’ç¼“å­˜ï¼Œä¿è¯æé€Ÿåˆ·æ–°
    def get_batch_estimations(_self, codes_list):
        """
        [V9.6 æ–°å¢] å¹¶å‘è·å–æŒ‡å®šåˆ—è¡¨çš„å®æ—¶ä¼°å€¼
        """
        results = {}
        # çº¿ç¨‹æ•°ä¸å®œè¿‡å¤šï¼Œé¿å…è¢«å°ï¼Œ20ä¸ªå¹¶å‘é€šå¸¸å®‰å…¨
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            future_to_code = {executor.submit(_self.fetch_single_estimation, code): code for code in codes_list}
            for future in concurrent.futures.as_completed(future_to_code):
                data = future.result()
                if data:
                    results[data['code']] = data
        return results

    @st.cache_data(ttl=1800) 
    def fetch_data(_self, fund_code, start_date='20190101', period='daily'): 
        try:
            try:
                df = ak.fund_open_fund_info_em(symbol=fund_code, indicator="å•ä½å‡€å€¼èµ°åŠ¿")
            except: return pd.DataFrame()
            
            df = df.rename(columns={"å‡€å€¼æ—¥æœŸ": "date", "å•ä½å‡€å€¼": "nav", "æ—¥å¢é•¿ç‡": "change"})
            df['date'] = pd.to_datetime(df['date'])
            df['nav'] = df['nav'].astype(float)
            df = df.sort_values('date')
            
            if period == 'weekly':
                df.set_index('date', inplace=True)
                df = df.resample('W').last().dropna().reset_index()

            mask = (df['date'] >= pd.to_datetime(start_date))
            df = df.loc[mask].reset_index(drop=True)
            return df
        except: return pd.DataFrame()

    def merge_realtime_data(self, df, realtime_info):
        """æ•°æ®èåˆå¼•æ“"""
        if df.empty or not realtime_info: return df, False
        
        last_date = df.iloc[-1]['date']
        est_nav = realtime_info.get('est_nav', 0)
        
        if est_nav <= 0: return df, False
        today = pd.Timestamp(datetime.date.today())
        
        # ç®€å•åˆ¤æ–­ï¼šå¦‚æœå†å²æ•°æ®ä¸æ˜¯ä»Šå¤©çš„ï¼Œå°±æŠŠä»Šå¤©çš„ä¼°å€¼æ¥ä¸Šå»
        if last_date < today:
            new_row = pd.DataFrame([{
                'date': today,
                'nav': est_nav,
                'change': realtime_info.get('est_pct', 0)
            }])
            df_merged = pd.concat([df, new_row], ignore_index=True)
            return df_merged, True
            
        return df, False

    def calculate_indicators(self, df):
        if df.empty: return df
        exp1 = df['nav'].ewm(span=12, adjust=False).mean()
        exp2 = df['nav'].ewm(span=26, adjust=False).mean()
        df['macd'] = exp1 - exp2
        df['signal'] = df['macd'].ewm(span=9, adjust=False).mean()
        df['tr'] = df['nav'].diff().abs()
        df['atr'] = df['tr'].rolling(window=14).mean()
        return df

    def find_pivots(self, df, order=10): 
        if df.empty: return []
        highs_idx = argrelextrema(df['nav'].values, np.greater, order=order)[0]
        lows_idx = argrelextrema(df['nav'].values, np.less, order=order)[0]
        pivots = []
        for idx in highs_idx: pivots.append({'date': df.iloc[idx]['date'], 'nav': df.iloc[idx]['nav'], 'type': 'high', 'index': idx, 'macd': df.iloc[idx]['macd']})
        for idx in lows_idx: pivots.append({'date': df.iloc[idx]['date'], 'nav': df.iloc[idx]['nav'], 'type': 'low', 'index': idx, 'macd': df.iloc[idx]['macd']})
        pivots.sort(key=lambda x: x['index'])
        if not pivots: return []
        clean = [pivots[0]]
        for curr in pivots[1:]:
            if curr['type'] != clean[-1]['type']: clean.append(curr)
        return clean

    def validate_impulse_wave(self, pivots):
        if len(pivots) < 6: return False, "ç‚¹æ•°ä¸è¶³", {}
        check_seq = pivots[-6:]
        if not (check_seq[0]['type'] == 'low' and check_seq[5]['type'] == 'high'): return False, "éä¸Šå‡5æµª", {}
        v = [p['nav'] for p in check_seq]
        if v[2] <= v[0]: return False, "è¿è§„:2æµªç ´åº•", {}
        if (v[3]-v[2] <= v[1]-v[0]) and (v[3]-v[2] <= v[5]-v[4]): return False, "è¿è§„:3æµªæœ€çŸ­", {}
        if v[4] <= v[1]: return False, "è¿è§„:4æµªé‡å ", {}
        return True, "æ ‡å‡†5æµªæ¨åŠ¨", {check_seq[i]['index']: str(i) for i in range(6)}

    def identify_wave_structure(self, pivots):
        is_valid, msg, labels = self.validate_impulse_wave(pivots)
        if is_valid: return msg, labels
        if len(pivots) >= 4:
            p = pivots[-4:]
            if p[0]['type'] == 'low' and p[1]['type'] == 'high' and p[2]['type'] == 'low' and p[3]['type'] == 'high':
                if p[2]['nav'] > p[0]['nav'] and p[3]['nav'] > p[1]['nav']:
                    return "ç–‘ä¼¼æµª3ä¸»å‡", {p[0]['index']:"1èµ·", p[1]['index']:"1é¡¶", p[2]['index']:"2åº•", p[3]['index']:"3é¡¶"}
        return "è°ƒæ•´/éœ‡è¡", {}

    def calculate_time_windows(self, pivots):
        if len(pivots) < 3: return []
        last_pivot = pivots[-1]
        prev_pivot = pivots[-2]
        wave_duration_days = (last_pivot['date'] - prev_pivot['date']).days
        if wave_duration_days <= 0: return []
        ratios = [0.618, 1.0, 1.618]
        projected_dates = []
        for r in ratios:
            delta = int(wave_duration_days * r)
            target_date = last_pivot['date'] + datetime.timedelta(days=delta)
            if target_date >= datetime.datetime.now(): 
                projected_dates.append((f"{r}å€", target_date.strftime('%Y-%m-%d')))
        return projected_dates

    def analyze_dynamic_status(self, df, pivots, cost, total_holding, new_holding_7d, realtime_info=None, total_capital=100000, risk_per_trade=2.0):
        """
        å…¨èƒ½åˆ†æå‡½æ•°
        """
        def return_defaults(status="æ•°æ®ä¸è¶³", color="gray", reason="æ— æ³•åˆ¤æ–­", instr="æ— æ“ä½œ"):
            return status, color, reason, {}, 0, instr, 0, 0, [], 0, 0, 0, {"target": 0, "desc": "æ— æ•°æ®", "low": 0, "high": 0}

        old_holding = total_holding - new_holding_7d
        if old_holding < 0: old_holding = 0
        if not pivots or len(pivots) < 4: return return_defaults()

        last_nav = df.iloc[-1]['nav']
        current_price = last_nav
        est_pct = 0 
        
        # å®æ—¶æ•°æ®å·²åœ¨ df ä¸­èåˆï¼Œè¿™é‡Œä»…ç”¨äºUIæ˜¾ç¤º
        if realtime_info and realtime_info.get('est_nav') > 0:
            est_pct = realtime_info['est_pct']
        
        last_pivot = pivots[-1]
        atr = df.iloc[-1]['atr'] if not pd.isna(df.iloc[-1]['atr']) else last_nav * 0.015
        
        recent_data = df.iloc[last_pivot['index']:]
        running_high = max(recent_data['nav'].max(), current_price) if last_pivot['type'] == 'low' else recent_data['nav'].max()
        if last_pivot['type'] == 'high': running_high = pivots[-2]['nav'] 

        wave_height = running_high - last_pivot['nav'] if last_pivot['type'] == 'low' else 0
        fib_levels = {}
        if wave_height > 0:
             fib_levels = {
                "High": running_high,
                "0.236": running_high - wave_height * 0.236,
                "0.382": running_high - wave_height * 0.382,
                "0.500": running_high - wave_height * 0.500,
                "0.618": running_high - wave_height * 0.618,
                "Low": last_pivot['nav']
            }
        
        plan_stop_loss = fib_levels.get('0.618', 0)
        buy_limit = fib_levels.get('0.618', 0)
        buy_stop = running_high * 1.01 
        
        risk_amount = total_capital * (risk_per_trade / 100)
        stop_dist = (current_price - (plan_stop_loss - atr)) 
        suggested_shares = 0
        if stop_dist > 0: suggested_shares = risk_amount / stop_dist

        instruction = "è§‚æœ›"
        reason = ""
        status = "åˆ†æä¸­"
        color = "gray"
        is_holding = total_holding > 0

        # === æŒ‡ä»¤ç”Ÿæˆå™¨ ===
        def generate_instruction(target_percent, risk_to_next_support=0, is_emergency=False):
            target_sell_amount = total_holding * target_percent
            sell_old = min(target_sell_amount, old_holding)
            needed_from_new = target_sell_amount - sell_old
            sell_new = 0
            prefix = "ğŸš¨ ç´§æ€¥å–å‡º" if is_emergency else "å–å‡º"
            if needed_from_new > 0:
                fee_rate = 0.015
                risk_delta = risk_to_next_support - fee_rate
                if target_percent >= 0.99: 
                    if risk_delta > 0 or is_emergency: sell_new = needed_from_new
                    else: sell_new = 0
                else: 
                    if risk_delta > 0.005: sell_new = needed_from_new
                    else: sell_new = 0
            
            total_sell = sell_old + sell_new
            if total_sell == 0: return "é”ä»“æŒæœ‰ (å–å‡ºä¸åˆ’ç®—)", "red"
            return f"{prefix} {total_sell:.2f} ä»½", "red" if is_emergency else "orange"

        # === é¢„æµ‹é€»è¾‘ ===
        forecast = {"target": 0, "desc": "éœ‡è¡", "low": 0, "high": 0}
        
        # === åˆ†æé€»è¾‘ ===
        if last_pivot['type'] == 'high': # ä¸‹è·Œä¸­
             status, color = "ä¸‹è·Œè¶‹åŠ¿", "red"
             risk = max((current_price - pivots[-2]['nav'] * 0.9) / current_price, 0.03)
             if is_holding:
                 instruction, color = generate_instruction(1.0, risk)
             else: instruction = "è§‚æœ›"
             reason = "ZigZagé«˜ç‚¹ç¡®ç«‹ï¼Œä¸»è·Œæµªé£é™©"
             forecast["target"] = current_price - atr; forecast["desc"] = "å¼±åŠ¿æ¢åº•"

        elif last_pivot['type'] == 'low': # ä¸Šå‡/å›è°ƒ
            current_retracement = (running_high - current_price) / wave_height if wave_height > 0 else 0
            
            prev_high_macd = -999
            current_macd = df.iloc[-1]['macd']
            for p in reversed(pivots):
                if p['type']=='high': prev_high_macd=p['macd']; break
            
            if current_price >= running_high * 0.98: # çªç ´
                 if current_price > pivots[-2]['nav'] and df.iloc[-1]['macd'] < prev_high_macd:
                     status, color = "æµª5èƒŒç¦»", "orange"
                     if is_holding: instruction, color = generate_instruction(0.5, 0)
                     else: instruction = "è§‚æœ›"
                     reason = "MACDé¡¶èƒŒç¦»"
                     forecast["target"] = current_price - atr; forecast["desc"] = "é«˜ä½é‡é˜»"
                 else:
                     status, color = "æµª3ä¸»å‡", "blue"
                     instruction = "æŒæœ‰ / è¿½æ¶¨"
                     reason = f"å¼ºåŠ¿çªç ´ï¼Œä¸Šæ–¹ç©ºé—´æ‰“å¼€"
                     forecast["target"] = current_price + atr; forecast["desc"] = "æƒ¯æ€§ä¸Šå†²"
            
            elif current_retracement < 0.236:
                status, color = "å¼ºåŠ¿æ•´ç†", "blue"
                instruction = "æŒæœ‰"
                reason = "ç©ºä¸­åŠ æ²¹"
                forecast["target"] = current_price + 0.5 * atr; forecast["desc"] = "é«˜ä½æ¨ªç›˜"
            
            elif 0.236 <= current_retracement < 0.382:
                status, color = "æ­£å¸¸å›è°ƒ", "blue"
                instruction = "åˆ†æ‰¹ä¹°å…¥"
                reason = "è‰¯æ€§æ´—ç›˜"
                forecast["target"] = fib_levels['0.382']; forecast["desc"] = "æ”¯æ’‘æµ‹è¯•"
            
            elif 0.382 <= current_retracement < 0.618:
                status, color = "æ·±åº¦å›è°ƒ", "orange"
                instruction = f"æŒ‚å• {fib_levels['0.618']:.4f}"
                if is_holding:
                    risk = (current_price - fib_levels['0.618']) / current_price
                    instruction, color = generate_instruction(0.3, risk)
                reason = "å…³æ³¨0.618æ”¯æ’‘"
                forecast["target"] = fib_levels['0.618']; forecast["desc"] = "å¯»æ‰¾åº•éƒ¨"
            
            else: # è·Œç ´ 0.618
                status, color = "è¶‹åŠ¿ç ´å", "red"
                risk = (current_price - fib_levels['Low']) / current_price
                if is_holding: instruction, color = generate_instruction(1.0, risk)
                else: instruction = "ä¸å®œä»‹å…¥"
                reason = "æœ‰æ•ˆè·Œç ´0.618"
                forecast["target"] = current_price - atr; forecast["desc"] = "åŠ é€Ÿä¸‹è·Œ"
        
        forecast["high"] = current_price + atr; forecast["low"] = current_price - atr

        # ç†”æ–­æ£€æŸ¥
        if realtime_info and current_price < plan_stop_loss and is_holding:
            status = "âš ï¸ è§¦å‘ç†”æ–­"
            risk_now = (current_price - fib_levels.get('Low', 0)) / current_price
            instruction, color = generate_instruction(1.0, risk_now, is_emergency=True)
            reason = f"å®æ—¶ä¼°å€¼å‡»ç©¿æ­¢æŸçº¿ {plan_stop_loss:.4f}"

        return status, color, reason, fib_levels, running_high, instruction, buy_limit, buy_stop, [], suggested_shares, current_price, est_pct, forecast

    def run_backtest(self, df, pivots):
        wins, losses = 0, 0
        for i in range(2, len(pivots)-1):
            p3, p2, p1 = pivots[i], pivots[i-1], pivots[i-2]
            if not (p1['type']=='low' and p2['type']=='high' and p3['type']=='low'): continue
            if p3['nav'] <= p1['nav']: continue 
            wave_h = p2['nav'] - p1['nav']
            retracement = (p2['nav'] - p3['nav']) / wave_h
            if 0.3 <= retracement <= 0.7:
                target = p3['nav'] + wave_h * 1.5
                stop = p1['nav']
                future = df[df['date'] > p3['date']]
                outcome = "HOLD"
                for _, r in future.iterrows():
                    if r['nav'] <= stop: outcome="LOSS"; break
                    elif r['nav'] >= target: outcome="WIN"; break
                if outcome=="WIN": wins+=1
                elif outcome=="LOSS": losses+=1
                elif not future.empty and future.iloc[-1]['nav'] > p3['nav']: wins+=1
        total = wins + losses
        win_rate = (wins / total * 100) if total > 0 else 0
        return {"win_rate": win_rate, "count": total}

# === æ¨¡æ‹Ÿç›˜ç³»ç»Ÿ ===
class PaperTradingSystem:
    def __init__(self, init_cash=100000):
        self.data = self._load_data(init_cash)
        
    def _load_data(self, init_cash):
        if os.path.exists(PAPER_TRADING_FILE):
            try:
                with open(PAPER_TRADING_FILE, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except: pass
        return {"cash": init_cash, "init_capital": init_cash, "holdings": {}, "history": [], "equity_curve": []}

    def _save_data(self):
        with open(PAPER_TRADING_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=4)

    def get_total_assets(self, rt_map=None):
        asset = self.data['cash']
        for code, info in self.data['holdings'].items():
            price = info['cost']
            if rt_map and code in rt_map: price = rt_map[code]['est_nav']
            asset += price * info['shares']
        return asset

    def execute_buy(self, code, name, price, amount):
        if self.data['cash'] < amount: return False, "èµ„é‡‘ä¸è¶³"
        fee = amount * 0.0015
        shares = (amount - fee) / price
        if code in self.data['holdings']:
            h = self.data['holdings'][code]
            h['cost'] = (h['cost'] * h['shares'] + amount) / (h['shares'] + shares)
            h['shares'] += shares
        else:
            self.data['holdings'][code] = {"name": name, "cost": price, "shares": shares, "max_price": price}
        self.data['cash'] -= amount
        self._save_data()
        return True, f"ä¹°å…¥ {name} {amount:.0f}å…ƒ"

    def execute_sell(self, code, price, shares, reason=""):
        if code not in self.data['holdings']: return False, "æœªæŒä»“"
        h = self.data['holdings'][code]
        amount = shares * price * (1 - 0.005)
        self.data['cash'] += amount
        h['shares'] -= shares
        if h['shares'] < 1: del self.data['holdings'][code]
        self._save_data()
        return True, f"å–å‡º {h['name']} ({reason})"

    def run_auto_pilot(self, analyzer, rt_map, risk_per_trade=2.0):
        logs = []
        scan_logs = [] 
        
        # 1. å–å‡ºé€»è¾‘
        codes = list(self.data['holdings'].keys())
        for code in codes:
            info = self.data['holdings'][code]
            df = analyzer.fetch_data(code)
            rt_info = rt_map.get(code)
            df_merged, _ = analyzer.merge_realtime_data(df, rt_info)
            df_final = analyzer.calculate_indicators(df_merged)
            
            if not df_final.empty:
                pivots = analyzer.find_pivots(df_final, order=10)
                res = analyzer.analyze_dynamic_status(df_final, pivots, info['cost'], info['shares'], 0, total_capital=self.get_total_assets(rt_map))
                status, _, _, _, _, instr, _, _, _, _, _, _, _ = res
                
                if any(k in instr for k in ["å–å‡º", "æ¸…ä»“", "æ­¢æŸ", "æ­¢ç›ˆ", "å‡ä»“", "è·åˆ©", "ç´§æ€¥"]):
                    match = re.search(r"([\d\.]+) ä»½", instr)
                    if match:
                        amt = float(match.group(1))
                        self.execute_sell(code, rt_info['est_nav'], amt, status)
                        logs.append(f"æ‰§è¡Œå–å‡º: {info['name']} {amt}ä»½ ({status})")
                    else:
                        amt = info['shares'] * 0.5
                        self.execute_sell(code, rt_info['est_nav'], amt, f"{status}(é»˜è®¤åŠä»“)")
                        logs.append(f"æ‰§è¡Œå–å‡º(é»˜è®¤): {info['name']} {amt}ä»½")

        # 2. ä¹°å…¥é€»è¾‘
        curr_assets = self.get_total_assets(rt_map)
        if self.data['cash'] / curr_assets > 0.2:
            hot_funds = analyzer.get_hot_funds()
            targets = hot_funds[:50] 
            
            for fund in targets:
                if self.data['cash'] < 5000: break
                if fund['code'] in self.data['holdings']: 
                    scan_logs.append(f"è·³è¿‡ {fund['name']}: å·²æŒä»“")
                    continue
                
                df = analyzer.fetch_data(fund['code'])
                rt_info = rt_map.get(fund['code'])
                df_merged, _ = analyzer.merge_realtime_data(df, rt_info)
                df_final = analyzer.calculate_indicators(df_merged)
                
                if not df_final.empty:
                    pivots = analyzer.find_pivots(df_final, order=10)
                    res = analyzer.analyze_dynamic_status(df_final, pivots, 0, 0, 0, total_capital=curr_assets, risk_per_trade=risk_per_trade)
                    status, _, reason, _, _, instr, _, _, _, shares, cur_p, _, _ = res
                    
                    if any(x in instr for x in ["ä¹°å…¥", "å»ºä»“", "è¿½æ¶¨", "æŒæœ‰"]):
                        buy_val = min(shares * cur_p, self.data['cash']) if shares > 0 else self.data['cash']*0.1
                        if buy_val > 1000:
                            self.execute_buy(fund['code'], fund['name'], cur_p, buy_val)
                            logs.append(f"ä¹°å…¥: {fund['name']} (ä¿¡å·:{status})")
                    else:
                        scan_logs.append(f"è½é€‰ {fund['name']}: {reason} (æŒ‡ä»¤:{instr})")
                else:
                    scan_logs.append(f"è·³è¿‡ {fund['name']}: æ•°æ®è·å–å¤±è´¥")
        
        return logs, scan_logs

def process_scan_item(args):
    analyzer, m_fund, order, capital, risk, rt_map, mode = args
    df = analyzer.fetch_data(m_fund['code'], period=mode)
    
    rt_info = rt_map.get(m_fund['code'])
    df_merged, has_rt = analyzer.merge_realtime_data(df, rt_info)
    df_final = analyzer.calculate_indicators(df_merged)
    
    if df_final.empty: return None
    pivots = analyzer.find_pivots(df_final, order=order)
    is_valid, struct_msg, _ = analyzer.validate_impulse_wave(pivots)
    
    res = analyzer.analyze_dynamic_status(
        df_final, pivots, 0, 0, 0, total_capital=capital, risk_per_trade=risk
    )
    status, _, _, _, _, instr, b_limit, b_stop, _, shares, cur_p, est_pct, forecast = res
    stats, _ = analyzer.run_backtest(df_final, pivots)
    score = stats['win_rate'] * stats['count']
    if is_valid: score += 500
    
    price_display = f"{cur_p:.4f}"
    if est_pct != 0: price_display += f" ({est_pct:+.2f}%)"
    if has_rt: price_display += " [Live]"
    
    return {
        "åç§°": m_fund['name'], "ä»£ç ": m_fund['code'], "çŠ¶æ€": status, "æŒ‡ä»¤": instr,
        "å®æ—¶ä¼°å€¼": price_display, "å»ºè®®ä»“ä½": f"{shares*cur_p:.0f}å…ƒ",
        "ç»“æ„": struct_msg, "èƒœç‡": f"{stats['win_rate']:.0f}%", "è¯„åˆ†": score,
        "æ˜æ—¥é¢„æµ‹": f"{forecast['target']:.4f}"
    }

# === UI ä¸»ç¨‹åº ===
def main():
    st.sidebar.title("ğŸ›  æŒ‡æŒ¥å®˜æ§åˆ¶å°")
    app_mode = st.sidebar.radio("ç³»ç»Ÿæ¨¡å¼", ["ğŸ“Š ä¸ªäººå®ç›˜è¯Šæ–­", "ğŸ¤– å…¨è‡ªåŠ¨æ¨¡æ‹Ÿç›˜"], index=1)
    
    analyzer = ElliottWaveAnalyzer()
    
    # 0. å¯åŠ¨æ—¶è·å–å…¨å¸‚åœºå®æ—¶ä¼°å€¼ (ä½¿ç”¨æ–°çš„ get_batch_estimations)
    codes_to_fetch = [f['code'] for f in MY_PORTFOLIO] + [f['code'] for f in STATIC_POOL]
    # å¦‚æœæ˜¯å…¨å¸‚åœºæ‰«ææ¨¡å¼ï¼Œè¿™é‡Œè¿˜éœ€è¦åŠ ä¸Šçƒ­é—¨åŸºé‡‘çš„codeï¼Œä½†ä¸ºäº†å¯åŠ¨é€Ÿåº¦ï¼Œæˆ‘ä»¬å¯ä»¥å»¶è¿Ÿè·å–
    
    with st.sidebar:
        if st.button("ğŸ”„ åˆ·æ–°å®æ—¶æ•°æ®"):
            st.cache_data.clear()
            st.success("åˆ·æ–°ä¸­...")
    
    # åˆå§‹è·å–ä¸€æ‰¹
    rt_map = analyzer.get_batch_estimations(codes_to_fetch)

    if app_mode == "ğŸ“Š ä¸ªäººå®ç›˜è¯Šæ–­":
        st.header("ğŸ“‚ ä¸ªäººå®ç›˜è¯Šæ–­ (æé€Ÿç›´è¿)")
        strategy_mode = st.radio("äº¤æ˜“é£æ ¼", ["çŸ­çº¿æ³¢æ®µ (æ—¥çº¿)", "é•¿çº¿æŠ•èµ„ (å‘¨çº¿)"], horizontal=True)
        period_param = 'weekly' if "å‘¨çº¿" in strategy_mode else 'daily'
        
        sim_new = st.slider("æ–°æŒä»“æ¨¡æ‹Ÿæ¯”ä¾‹", 0.0, 1.0, 0.0)
        zigzag_order = st.slider("æ³¢æµªçµæ•åº¦", 5, 30, 10)
        
        for fund in MY_PORTFOLIO:
            df = analyzer.fetch_data(fund['code'], period=period_param)
            with st.expander(f"ğŸ“Š {fund['name']}", expanded=False):
                if df.empty: st.error("No Data"); continue
                
                fund_rt = rt_map.get(fund['code'])
                df_merged, has_rt = analyzer.merge_realtime_data(df, fund_rt)
                df_final = analyzer.calculate_indicators(df_merged)
                
                eff_new = fund.get('hold_7d', 0) if sim_new == 0 else fund['hold'] * sim_new
                pivots = analyzer.find_pivots(df_final, order=zigzag_order)
                struct_msg, labels = analyzer.identify_wave_structure(pivots)
                
                res = analyzer.analyze_dynamic_status(df_final, pivots, fund['cost'], fund['hold'], eff_new, realtime_info=fund_rt)
                status, color, reason, fibs, _, instr, _, _, _, _, est_price, est_pct, forecast = res
                
                c1, c2, c3 = st.columns([1,1,2])
                price_label = f"å®æ—¶ä¼°å€¼ ({fund_rt['time'][-8:]})" if has_rt and 'time' in fund_rt else "å‡€å€¼"
                c1.metric(price_label, f"{est_price:.4f}", f"{est_pct:+.2f}%")
                c2.metric("çŠ¶æ€", status, delta_color="normal" if color=="blue" else "inverse")
                instr_color = "red" if "å–" in instr or "æŸ" in instr else "green"
                c3.markdown(f"### æŒ‡ä»¤: <span style='color:{instr_color}'>{instr}</span>", unsafe_allow_html=True)
                
                st.info(f"ğŸ”® **æ˜æ—¥é¢„æµ‹**: {forecast['target']:.4f} ({forecast['desc']})\n"
                        f"ğŸŒŠ **ç»“æ„**: {struct_msg} | **é€»è¾‘**: {reason}")
                
                fig = go.Figure()
                fig.add_trace(go.Scatter(x=df_final['date'], y=df_final['nav'], mode='lines', name='å‡€å€¼'))
                
                p_dates = [p['date'] for p in pivots]
                p_navs = [p['nav'] for p in pivots]
                if pivots:
                    p_dates.append(df_final.iloc[-1]['date'])
                    p_navs.append(df_final.iloc[-1]['nav'])
                fig.add_trace(go.Scatter(x=p_dates, y=p_navs, mode='lines', name='æ³¢æµªç»“æ„', line=dict(color='orange', dash='dot')))
                
                for idx, label in labels.items():
                    if idx < len(df_final):
                        row = df_final.iloc[idx]
                        fig.add_annotation(x=row['date'], y=row['nav'], text=label, showarrow=True, arrowhead=1)
                
                if has_rt:
                    fig.add_trace(go.Scatter(x=[df_final.iloc[-1]['date']], y=[df_final.iloc[-1]['nav']], mode='markers', marker=dict(color='red', size=12, symbol='star'), name='ç›˜ä¸­å®æ—¶'))

                if fibs:
                    fig.add_hline(y=fibs['0.618'], line_dash="solid", line_color="red", annotation_text="0.618")
                    fig.add_hline(y=fibs['0.382'], line_dash="dot", line_color="orange", annotation_text="0.382")
                    
                st.plotly_chart(fig, use_container_width=True)

    # === æ¨¡å¼äºŒï¼šæ¨¡æ‹Ÿç›˜ ===
    elif app_mode == "ğŸ¤– å…¨è‡ªåŠ¨æ¨¡æ‹Ÿç›˜":
        st.title("ğŸ¤– æ³¢æµªç†è®ºå…¨è‡ªåŠ¨æ¨¡æ‹Ÿäº¤æ˜“ç³»ç»Ÿ")
        pt = PaperTradingSystem()
        
        # è¡¥å…¨æ¨¡æ‹Ÿç›˜æŒä»“çš„å®æ—¶æ•°æ®
        holding_codes = list(pt.data['holdings'].keys())
        if holding_codes:
            rt_map.update(analyzer.get_batch_estimations(holding_codes))

        curr_assets = pt.get_total_assets(rt_map)
        init_cap = pt.data['init_capital']
        pnl = curr_assets - init_cap
        pnl_pct = pnl / init_cap * 100
        pos_ratio = (curr_assets - pt.data['cash']) / curr_assets * 100
        
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("æ€»èµ„äº§", f"{curr_assets:,.2f}", f"{pnl_pct:+.2f}%")
        c2.metric("å¯ç”¨ç°é‡‘", f"{pt.data['cash']:,.2f}")
        c3.metric("æŒä»“ç›ˆäº", f"{pnl:,.2f}")
        c4.metric("ä»“ä½", f"{pos_ratio:.1f}%")

        st.markdown("---")
        if st.button("ğŸš€ è¿è¡Œä»Šæ—¥ç­–ç•¥ (åŸºäºå®æ—¶æ•°æ®)", type="primary"):
            with st.spinner("æ­£åœ¨èåˆå®æ—¶æ•°æ®å¹¶æ‰§è¡Œç­–ç•¥..."):
                # è·å–çƒ­é—¨åŸºé‡‘å¹¶æŠ“å–å®æ—¶æ•°æ®
                hot_funds = analyzer.get_hot_funds()
                hot_codes = [f['code'] for f in hot_funds]
                # æ‰¹é‡è·å–çƒ­é—¨åŸºé‡‘çš„å®æ—¶æ•°æ®
                rt_map.update(analyzer.get_batch_estimations(hot_codes))
                
                logs, scan_logs = pt.run_auto_pilot(analyzer, rt_map)
            
            if logs:
                for log in logs: st.toast(log)
                st.success(f"æ‰§è¡Œå®Œæ¯•ï¼Œäº§ç”Ÿ {len(logs)} ç¬”äº¤æ˜“")
            else:
                st.info("ç›˜ä¸­æ‰«æå®Œæ¯•ï¼Œæš‚æ— æˆäº¤")
            
            with st.expander("æŸ¥çœ‹é€‰è‚¡æ‰«ææ—¥å¿— (Top 50)", expanded=False):
                st.write(f"å…±æ‰«æ {len(scan_logs)} åªåŸºé‡‘")
                for sl in scan_logs[:20]: st.text(sl)
                if len(scan_logs) > 20: st.text("...")
            
            time.sleep(1)
        
        tab1, tab2, tab3 = st.tabs(["å½“å‰æŒä»“", "èµ„äº§æ›²çº¿", "äº¤æ˜“å†å²"])
        with tab1:
            holdings = pt.data['holdings']
            if not holdings: st.info("å½“å‰ç©ºä»“")
            else:
                h_data = []
                for c, v in holdings.items():
                    curr = rt_map.get(c, {}).get('est_nav', v['cost'])
                    mv = curr * v['shares']
                    prof = mv - v['cost'] * v['shares']
                    h_data.append({"ä»£ç ": c, "åç§°": v['name'], "æˆæœ¬": f"{v['cost']:.4f}", "ç°ä»·": f"{curr:.4f}", "å¸‚å€¼": f"{mv:.0f}", "ç›ˆäº": f"{prof:+.0f}"})
                st.dataframe(pd.DataFrame(h_data), use_container_width=True)
        # ... (tab2, tab3 ä¿æŒä¸å˜) ...

    # ... (å¸‚åœºæ‰«æéƒ¨åˆ†) ...
    st.markdown("---")
    st.header("ğŸš€ å…¨å¸‚åœºä½œæˆ˜æœºä¼š (å®æ—¶èåˆ)")
    if st.button("å¼€å§‹æ‰«æ", type="primary"):
        progress = st.progress(0)
        results = []
        market_list = STATIC_POOL 
        hot_list = analyzer.get_hot_funds()
        existing = set(m['code'] for m in market_list)
        for h in hot_list:
            if h['code'] not in existing: market_list.append(h)
        
        # æ‰¹é‡è·å–æ‰€æœ‰æ‰«æå¯¹è±¡çš„å®æ—¶æ•°æ®
        all_scan_codes = [m['code'] for m in market_list]
        with st.spinner("æ­£åœ¨å¹¶å‘è·å–å®æ—¶ä¼°å€¼..."):
            rt_map.update(analyzer.get_batch_estimations(all_scan_codes))
        
        status_text = st.empty()
        total_tasks = len(market_list)
        
        for i, m in enumerate(market_list):
            status_text.text(f"æ­£åœ¨æ‰«æ: {m['name']} ({i+1}/{total_tasks})...")
            args = (analyzer, m, 10, 100000, 2.0, rt_map, 'daily')
            try:
                res = process_scan_item(args)
                if res: results.append(res)
            except: pass
            progress.progress((i + 1) / total_tasks)
        
        status_text.empty()
        if results:
            df_res = pd.DataFrame(results).sort_values(by="è¯„åˆ†", ascending=False)
            def highlight(val):
                if "ä¹°å…¥" in val or "æŒæœ‰" in val or "è¿½æ¶¨" in val: return 'color: green; font-weight: bold'
                return ''
            st.dataframe(df_res.style.map(highlight, subset=["æŒ‡ä»¤"]), use_container_width=True)

if __name__ == "__main__":
    main()